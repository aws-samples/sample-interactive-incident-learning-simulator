import {
  EC2Client,
  AuthorizeSecurityGroupIngressCommand,
  DescribeIamInstanceProfileAssociationsCommand,
  ReplaceIamInstanceProfileAssociationCommand,
  ReplaceIamInstanceProfileAssociationCommandInput,
} from "@aws-sdk/client-ec2";
import { S3Client, PutPublicAccessBlockCommand } from "@aws-sdk/client-s3";
import {
  CloudTrailClient,
  StopLoggingCommand,
} from "@aws-sdk/client-cloudtrail";
import { ResourceHelper } from "./resource-helper";

// AWS SDKクライアントの初期化
const ec2Client = new EC2Client();
const s3Client = new S3Client();
const cloudtrailClient = new CloudTrailClient();

/**
 * 選択されたリソースに脆弱性を注入する関数
 */
export async function injectVulnerability(
  resourceType: string,
  resourceInfo: any,
) {
  if (!resourceInfo) {
    throw new Error(`Resource information not found for ${resourceType}`);
  }

  // ダミーIDの場合はモックとして扱い、実際のAPI呼び出しをスキップ
  if (
    resourceInfo.ResourceId === "i-dummy" ||
    resourceInfo.ResourceId.startsWith("dummy-") ||
    resourceInfo.ResourceId.startsWith("sg-dummy")
  ) {
    console.log(
      `[MOCK] Simulating vulnerability injection for ${resourceType} with dummy ID ${resourceInfo.ResourceId}`,
    );
    return;
  }

  switch (resourceType) {
    case "ALB_SG":
      await injectAlbSecurityGroupVulnerability(resourceInfo.ResourceId);
      break;
    case "EC2_SG":
      await injectEc2SecurityGroupVulnerability(resourceInfo.ResourceId);
      break;
    case "EC2_SAFE_ROLE":
      await injectEc2RoleVulnerability(resourceInfo.ResourceId);
      break;
    case "S3_BUCKET":
      await injectS3BucketVulnerability(resourceInfo.ResourceId);
      break;
    case "RDS_SG":
      await injectRdsSecurityGroupVulnerability(resourceInfo.ResourceId);
      break;
    case "CLOUDTRAIL":
      await injectCloudTrailVulnerability(resourceInfo.ResourceId);
      break;
    default:
      throw new Error(`Unsupported resource type: ${resourceType}`);
  }
}

/**
 * ALBのセキュリティグループに脆弱性を注入する関数
 * - インバウンドにソース0.0.0.0/0からsshポート通信許可が設定される
 */
export async function injectAlbSecurityGroupVulnerability(
  securityGroupId: string,
) {
  try {
    const params = {
      GroupId: securityGroupId,
      IpPermissions: [
        {
          IpProtocol: "tcp",
          FromPort: 22,
          ToPort: 22,
          IpRanges: [
            {
              CidrIp: "0.0.0.0/0",
              Description: "SSH access from anywhere - SECURITY VULNERABILITY",
            },
          ],
        },
      ],
    };

    await ec2Client.send(new AuthorizeSecurityGroupIngressCommand(params));
    console.log(
      `Added SSH access from anywhere to ALB security group ${securityGroupId}`,
    );
  } catch (error: any) {
    // ルールが既に存在する場合は無視
    if (error.code === "InvalidPermission.Duplicate") {
      console.log(
        `SSH access rule already exists for ALB security group ${securityGroupId}`,
      );
    } else {
      console.error(
        `Error adding SSH access to ALB security group: ${error.message}`,
      );
      // エラーが発生しても処理を続行
      console.log("Continuing with security group vulnerability simulation");
    }
  }
}

/**
 * EC2のセキュリティグループに脆弱性を注入する関数
 * - インバウンドにソース0.0.0.0/0からsshポート通信許可が設定される
 */
export async function injectEc2SecurityGroupVulnerability(
  securityGroupId: string,
) {
  try {
    const params = {
      GroupId: securityGroupId,
      IpPermissions: [
        {
          IpProtocol: "tcp",
          FromPort: 22,
          ToPort: 22,
          IpRanges: [
            {
              CidrIp: "0.0.0.0/0",
              Description: "SSH access from anywhere - SECURITY VULNERABILITY",
            },
          ],
        },
      ],
    };

    await ec2Client.send(new AuthorizeSecurityGroupIngressCommand(params));
    console.log(
      `Added SSH access from anywhere to EC2 security group ${securityGroupId}`,
    );
  } catch (error: any) {
    // ルールが既に存在する場合は無視
    if (error.code === "InvalidPermission.Duplicate") {
      console.log(
        `SSH access rule already exists for EC2 security group ${securityGroupId}`,
      );
    } else {
      console.error(
        `Error adding SSH access to EC2 security group: ${error.message}`,
      );
      // エラーが発生しても処理を続行
      console.log("Continuing with security group vulnerability simulation");
    }
  }
}

/**
 * EC2のIAMロールに脆弱性を注入する関数
 * - UnsafeRole がアタッチされたインスタンスプロファイルに付け替える
 */
export async function injectEc2RoleVulnerability(roleName: string) {
  try {
    console.log(
      `Starting EC2 role vulnerability injection process for role: ${roleName}`,
    );

    // ResourceHelperを初期化
    const resourceHelper = new ResourceHelper();

    // UnsafeRoleのリソースIDを取得
    const unsafeRoleInfo =
      await resourceHelper.getResourceInfo("EC2_UNSAFE_ROLE");
    if (!unsafeRoleInfo || !unsafeRoleInfo.ResourceId) {
      throw new Error("Unsafe role information not found");
    }
    const unsafeRoleName = unsafeRoleInfo.ResourceId;
    console.log(`Retrieved unsafe role: ${unsafeRoleName}`);

    // EC2インスタンスのIDを取得
    const instance1Info =
      await resourceHelper.getResourceInfo("EC2_INSTANCE_1");
    const instance2Info =
      await resourceHelper.getResourceInfo("EC2_INSTANCE_2");
    const instances = [instance1Info.ResourceId, instance2Info.ResourceId];

    if (
      !instance1Info ||
      !instance1Info.ResourceId ||
      !instance2Info ||
      !instance2Info.ResourceId
    ) {
      throw new Error("EC2 instance information not found");
    }

    const response = await ec2Client.send(
      new DescribeIamInstanceProfileAssociationsCommand({
        Filters: [
          {
            Name: "instance-id",
            Values: instances,
          },
        ],
      }),
    );

    if (!response.IamInstanceProfileAssociations) {
      throw new Error("No instance profiles.");
    }

    for (const association of response.IamInstanceProfileAssociations) {
      const param: ReplaceIamInstanceProfileAssociationCommandInput = {
        IamInstanceProfile: {
          Arn: unsafeRoleInfo.ResourceArn,
        },
        AssociationId: association.AssociationId,
      };

      // Instance Profile を replace する
      await ec2Client.send(
        new ReplaceIamInstanceProfileAssociationCommand(param),
      );
    }

    console.log("EC2 role vulnerability injection completed successfully");
  } catch (error: any) {
    console.error(`Error injecting EC2 role vulnerability: ${error.message}`);
    // エラーが発生しても処理を続行
    console.log("Continuing with role vulnerability simulation");
  }
}

/**
 * S3バケットに脆弱性を注入する関数
 * - パブリックアクセスブロックがOFFになる
 */
export async function injectS3BucketVulnerability(bucketName: string) {
  try {
    // パブリックアクセスブロックをOFFにする
    const params = {
      Bucket: bucketName,
      PublicAccessBlockConfiguration: {
        BlockPublicAcls: false,
        IgnorePublicAcls: false,
        BlockPublicPolicy: false,
        RestrictPublicBuckets: false,
      },
    };

    await s3Client.send(new PutPublicAccessBlockCommand(params));
    console.log(`Disabled public access block for S3 bucket ${bucketName}`);
  } catch (error: any) {
    console.error(
      `Error disabling public access block for S3 bucket: ${error.message}`,
    );
    // エラーが発生しても処理を続行
    console.log("Continuing with S3 bucket vulnerability simulation");
  }
}

/**
 * RDSのセキュリティグループに脆弱性を注入する関数
 * - インバウンドにソース0.0.0.0/0からポート3306通信許可が設定される
 */
export async function injectRdsSecurityGroupVulnerability(
  securityGroupId: string,
) {
  try {
    const params = {
      GroupId: securityGroupId,
      IpPermissions: [
        {
          IpProtocol: "tcp",
          FromPort: 3306,
          ToPort: 3306,
          IpRanges: [
            {
              CidrIp: "0.0.0.0/0",
              Description:
                "MySQL access from anywhere - SECURITY VULNERABILITY",
            },
          ],
        },
      ],
    };

    await ec2Client.send(new AuthorizeSecurityGroupIngressCommand(params));
    console.log(
      `Added MySQL access from anywhere to RDS security group ${securityGroupId}`,
    );
  } catch (error: any) {
    // ルールが既に存在する場合は無視
    if (error.code === "InvalidPermission.Duplicate") {
      console.log(
        `MySQL access rule already exists for RDS security group ${securityGroupId}`,
      );
    } else {
      console.error(
        `Error adding MySQL access to RDS security group: ${error.message}`,
      );
      // エラーが発生しても処理を続行
      console.log("Continuing with security group vulnerability simulation");
    }
  }
}

/**
 * CloudTrailに脆弱性を注入する関数
 * - CloudTrailの設定が無効になる
 */
export async function injectCloudTrailVulnerability(trailName: string) {
  // IsengardのCloudTrailは変更しない
  if (trailName === "IsengardTrail-DO-NOT-DELETE") {
    console.log(`[SIMULATION] Skipping Isengard CloudTrail: ${trailName}`);
    return;
  }

  try {
    await cloudtrailClient.send(
      new StopLoggingCommand({
        Name: trailName,
      }),
    );

    console.log(`Stopped logging for CloudTrail ${trailName}`);
  } catch (error: any) {
    console.error(`Error stopping CloudTrail ${trailName}: ${error.message}`);
    // エラーが発生しても処理を続行
    console.log("Continuing with CloudTrail vulnerability simulation");
  }
}
